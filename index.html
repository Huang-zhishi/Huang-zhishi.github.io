<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>致符程洁</title>
    <style>
        /* --- 基础重置 --- */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background-color: #080002;
            overflow: hidden;
            font-family: "PingFang SC", "Microsoft YaHei", sans-serif;
            width: 100vw;
            height: 100vh;
            position: relative;
            /* 防止移动端触摸滚动和双击缩放 */
            touch-action: none; 
        }

        /* --- 画布层级管理 --- */
        /* 1. 爱心粒子层 (底层) */
        #heart-canvas {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 1;
        }
        /* 2. 交互流星轨迹层 (中层) */
        #interaction-canvas {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 2;
            pointer-events: none; /* 让事件穿透，由 JS 监听 window */
        }

        /* --- DOM 元素层 --- */
        /* 背景流星 (CSS动画实现) */
        .bg-meteor {
            position: absolute;
            width: 2px; height: 80px;
            background: linear-gradient(to bottom, rgba(255,255,255,0) 0%, rgba(255,255,255,0.8) 50%, #ffffff 100%);
            border-radius: 50%; opacity: 0; z-index: 0; pointer-events: none;
        }
        @keyframes meteor-fall {
            0% { opacity: 1; transform: translate(0, 0) rotate(-35deg) scaleY(0.8); }
            20% { opacity: 1; }
            100% { opacity: 0; transform: translate(-50vh, 50vh) rotate(-35deg) scaleY(1); }
        }

        /* 诗词层 */
        #poems-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 3; pointer-events: none;
        }
        .poem-item {
            position: absolute; color: rgba(255, 255, 255, 0.4);
            text-shadow: 0 0 2px rgba(255, 192, 203, 0.3);
            white-space: nowrap; font-style: italic;
            transition: opacity 1s ease-out, transform 5s ease-out; opacity: 0;
        }

        /* 核心文字层 */
        #message-container {
            position: absolute; top: 55%; left: 50%;
            transform: translate(-50%, -50%); z-index: 4;
            text-align: center; pointer-events: none; width: 95%;
            display: flex; justify-content: center; flex-wrap: wrap; align-items: baseline;
        }
        .char {
            display: inline-block; font-size: 1.8rem; color: #fff; margin: 0 2px;
            font-weight: bold; text-shadow: 0 0 10px rgba(255, 77, 109, 0.8);
            opacity: 0; transform: translateY(30px) scale(0.5);
            transition: all 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275); filter: blur(5px);
        }
        .char.visible {
            opacity: 1; transform: translateY(0) scale(1); filter: blur(0);
            animation: textFloat 3s ease-in-out infinite alternate;
        }
        .char.name-style {
            font-size: 2.2rem; color: #ff4d6d;
            text-shadow: 0 0 15px rgba(255, 0, 0, 0.9), 0 0 30px rgba(255, 77, 109, 0.6);
        }
        @keyframes textFloat { 0% { transform: translateY(0); } 100% { transform: translateY(-8px); } }
        @media (min-width: 400px) { .char { font-size: 2rem; } .char.name-style { font-size: 2.5rem; } }

        /* 启动提示层 */
        #start-trigger {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 999; display: flex; justify-content: center; align-items: center;
            color: rgba(255,255,255,0.8); font-size: 1.2rem; background: rgba(0,0,0,0.4);
            cursor: pointer; animation: pulse 2s infinite; user-select: none;
        }
        @keyframes pulse { 0% { opacity: 0.7; } 50% { opacity: 1; } 100% { opacity: 0.7; } }
    </style>
</head>
<body>

    <audio id="bg-music" loop preload="auto">
        <source src="love.mp3" type="audio/mpeg">
    </audio>
    
    <div id="start-trigger">点击屏幕 开始以爱之名</div>

    <canvas id="heart-canvas"></canvas>
    <canvas id="interaction-canvas"></canvas>

    <div id="poems-container"></div>
    <div id="message-container"></div>

    <script>
        const CONFIG = {
            HEART_COLOR: '#ff4d6d',
            PARTICLE_COUNT: 1500,
            TARGET_TEXT: "我爱你，符程洁",
            POEM_LIST: [
                "山有木兮木有枝", "心悦君兮君不知", "愿得一心人", "白首不相离",
                "玲珑骰子安红豆", "入骨相思知不知", "金风玉露一相逢", "便胜却人间无数",
                "两情若是久长时", "又岂在朝朝暮暮", "斯人若彩虹", "遇上方知有",
                "也想看看你的眼里", "是不是住着四季", "想和你一起去看流星雨"
            ]
        };

        // ================= 1. 背景流星系统 (DOM实现) =================
        function startBackgroundMeteors() {
            const container = document.body;
            setInterval(() => {
                // 限制数量
                if (document.querySelectorAll('.bg-meteor').length > 6) return;
                const meteor = document.createElement('div');
                meteor.classList.add('bg-meteor');
                // 随机位置：屏幕右上方
                meteor.style.left = (Math.random() * 60 + 40) + 'vw'; 
                meteor.style.top = (Math.random() * 200 - 100) + 'px';
                const duration = Math.random() * 1.5 + 2; // 2s - 3.5s
                meteor.style.animation = `meteor-fall ${duration}s linear forwards`;
                container.appendChild(meteor);
                setTimeout(() => meteor.remove(), duration * 1000 + 200);
            }, Math.random() * 1500 + 1000);
        }

        // ================= 2. 爱心粒子系统 (Canvas 1) =================
        class HeartSystem {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.width = window.innerWidth; this.height = window.innerHeight;
                this.particles = [];
                this.canvas.width = this.width; this.canvas.height = this.height;
                this.initParticles(); this.animate();
                window.addEventListener('resize', () => this.resize());
            }
            getHeartPosition(scale) {
                const t = Math.random() * Math.PI * 2; const r = Math.sqrt(Math.random());
                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = -(13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t));
                return { x: x * r * scale, y: y * r * scale };
            }
            initParticles() {
                this.particles = []; const scale = Math.min(this.width, this.height) / 40;
                for (let i = 0; i < CONFIG.PARTICLE_COUNT; i++) {
                    const pos = this.getHeartPosition(scale);
                    this.particles.push({
                        x: this.width/2 + pos.x, y: this.height/2 + pos.y - 20,
                        baseX: this.width/2 + pos.x, baseY: this.height/2 + pos.y - 20,
                        size: Math.random() * 1.5 + 0.5,
                        color: i % 2 === 0 ? CONFIG.HEART_COLOR : '#ff758f',
                        velocity: { x: (Math.random()-0.5)*0.3, y: (Math.random()-0.5)*0.3 }
                    });
                }
            }
            resize() {
                this.width = window.innerWidth; this.height = window.innerHeight;
                this.canvas.width = this.width; this.canvas.height = this.height;
                this.initParticles();
            }
            animate() {
                this.ctx.fillStyle = 'rgba(8, 0, 2, 0.1)'; // 拖尾效果核心
                this.ctx.fillRect(0, 0, this.width, this.height);
                const beatScale = 1 + Math.sin(Date.now() * 0.003) * 0.03;
                this.particles.forEach(p => {
                    p.x += p.velocity.x; p.y += p.velocity.y;
                    const dx = p.x - p.baseX; const dy = p.y - p.baseY;
                    if (Math.abs(dx) > 3) p.velocity.x = -dx * 0.02;
                    if (Math.abs(dy) > 3) p.velocity.y = -dy * 0.02;
                    const cx = this.width/2; const cy = this.height/2 - 20;
                    this.ctx.beginPath();
                    this.ctx.arc((p.x-cx)*beatScale+cx, (p.y-cy)*beatScale+cy, p.size, 0, Math.PI*2);
                    this.ctx.fillStyle = p.color; this.ctx.fill();
                });
                requestAnimationFrame(() => this.animate());
            }
        }

        // ================= 3. 全新：交互流星轨迹系统 (Canvas 2) =================
        class InteractionSystem {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.width = window.innerWidth; this.height = window.innerHeight;
                this.canvas.width = this.width; this.canvas.height = this.height;
                this.trails = [];
                this.initListeners(); this.animate();
                window.addEventListener('resize', () => {
                    this.width = window.innerWidth; this.height = window.innerHeight;
                    this.canvas.width = this.width; this.canvas.height = this.height;
                });
            }
            initListeners() {
                // 监听移动端触摸和桌面端鼠标移动
                const handleMove = (e) => {
                    let x, y;
                    if (e.touches) {
                        x = e.touches[0].clientX; y = e.touches[0].clientY;
                    } else {
                        x = e.clientX; y = e.clientY;
                    }
                    // 每次移动生成几个粒子
                    for(let i=0; i<3; i++) this.createTrailParticle(x, y);
                };
                window.addEventListener('touchmove', handleMove, { passive: true });
                window.addEventListener('mousemove', handleMove);
            }
            createTrailParticle(x, y) {
                this.trails.push({
                    x: x + (Math.random() - 0.5) * 10, // 在触点附近随机偏移
                    y: y + (Math.random() - 0.5) * 10,
                    size: Math.random() * 3 + 1,
                    speedX: (Math.random() - 0.5) * 2,
                    speedY: (Math.random() - 0.5) * 2 + 1, // 稍微向下掉落
                    life: 1, // 生命值 1 -> 0
                    color: `hsl(${Math.random() * 60 + 330}, 100%, 70%)` // 粉红到橙黄色系
                });
            }
            animate() {
                // 清空画布，不需要拖尾，因为粒子本身有生命周期
                this.ctx.clearRect(0, 0, this.width, this.height);
                for (let i = 0; i < this.trails.length; i++) {
                    const p = this.trails[i];
                    p.x += p.speedX; p.y += p.speedY;
                    p.life -= 0.015; // 生命值递减
                    if (p.life <= 0) {
                        this.trails.splice(i, 1); i--; continue;
                    }
                    this.ctx.beginPath();
                    this.ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2); //大小随生命值变小
                    // 使用径向渐变让粒子看起来发光
                    const gradient = this.ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * p.life);
                    gradient.addColorStop(0, "rgba(255, 255, 255, " + p.life + ")");
                    gradient.addColorStop(1, p.color.replace(")", ", " + p.life * 0.5 + ")"));
                    this.ctx.fillStyle = gradient;
                    this.ctx.fill();
                }
                requestAnimationFrame(() => this.animate());
            }
        }

        // ================= 4. 辅助逻辑 (诗词、文字、启动) =================
        function startPoems() { /* ... 代码与之前相同，省略以节省空间 ... */ 
            const container = document.getElementById('poems-container');
            setInterval(() => {
                const text = CONFIG.POEM_LIST[Math.floor(Math.random() * CONFIG.POEM_LIST.length)];
                const el = document.createElement('div');
                el.className = 'poem-item'; el.innerText = text;
                let x = Math.random() * (window.innerWidth - 80); let y = Math.random() * (window.innerHeight - 40);
                if (Math.abs(x - window.innerWidth / 2) < 120 && Math.abs(y - window.innerHeight / 2) < 100) y = Math.random() < 0.5 ? y - 150 : y + 150;
                el.style.left = x + 'px'; el.style.top = y + 'px'; el.style.fontSize = (Math.random() * 4 + 12) + 'px';
                container.appendChild(el);
                requestAnimationFrame(() => { el.style.opacity = '1'; el.style.transform = `translateY(-${Math.random() * 30 + 30}px)`; });
                setTimeout(() => { el.style.opacity = '0'; setTimeout(() => el.remove(), 1000); }, 4000);
            }, 1200);
        }
        function startTextReveal() { /* ... 代码与之前相同，省略以节省空间 ... */ 
            const container = document.getElementById('message-container');
            const text = CONFIG.TARGET_TEXT; let index = 0;
            const timer = setInterval(() => {
                if (index >= text.length) { clearInterval(timer); return; }
                const char = text[index]; const span = document.createElement('span');
                span.innerText = char; span.className = 'char';
                if (index >= 4) span.classList.add('name-style');
                container.appendChild(span);
                requestAnimationFrame(() => { span.classList.add('visible'); });
                index++;
            }, 350);
        }

        // ================= 入口函数 =================
        window.onload = () => {
            // 立即启动的系统
            new HeartSystem('heart-canvas');
            new InteractionSystem('interaction-canvas');
            startPoems();
            
            const audio = document.getElementById('bg-music');
            const trigger = document.getElementById('start-trigger');

            // 点击触发音乐和背景流星/文字
            trigger.addEventListener('click', () => {
                audio.play().then(() => {
                    console.log("Music playing...");
                }).catch(e => console.log("Play failed check file path:", e));
                
                trigger.style.opacity = '0';
                setTimeout(() => trigger.remove(), 500);

                // 延迟启动高消耗的背景动画和文字，保证点击时的流畅度
                setTimeout(() => {
                    startBackgroundMeteors();
                    startTextReveal();
                }, 300);
            }, { once: true });
        };

    </script>
</body>
</html>
